# Введение | Документация Metalfish OS

## [Главная страница](./index.md)

Мetalfish OS - это свободная, открытая операционная система для x86_64 архитектуры на ассемблере NASM и C (компилятор GCC).

Metalfish OS состоит из двух слов - metal (англ. металл) и fish (англ. рыба). Это означает, что эта операционная система гибкая, как рыба, и стабильная и твердая, как металл.

Язык Ассемблер — это низкоуровневый язык программирования для компьютеров или других программируемых устройств, он специфичен для конкретной компьютерной архитектуры центрального процессора, что отличает его от большинства высокоуровневых языков программирования, которые обычно портативны среди разных систем. Язык Ассемблер преобразуется в исполняемый машинный код с помощью служебной программы, называемой ассемблером, такой как NASM, MASM и т. д.

Каждый персональный компьютер имеет микропроцессор, который управляет арифметической, логической и контрольной активностью.

Каждая семья процессоров имеет свой собственный набор инструкций для обработки различных операций, таких как получения ввода с клавиатуры, отображение информации на экране и выполнения различных других работ. Этот набор инструкций называется «инструкции машинного языка» ('machine language instructions').

Процессор понимает только инструкции машинного языка, которые являются строками из единиц и нулей. При этом машинный язык слишком непонятный и сложный для использования его в разработки программного обеспечения. И низкоуровневый язык Ассемблер предназначен для определённый групп процессоров, он представляет различные инструкции в символическом коде и более понятной форме.

## Системы счисления

### Основные характеристики аппаратной составляющей ПК

Каждый компьютер содержит процессор и оперативную память. Процессор содержит регистры — компоненты, которые содержат данные и адреса. Для выполнения программы, система копирует её с устройства постоянного хранения во внутреннюю память. Процессор выполняет инструкции программы.

Фундаментальной единицей компьютерного хранилища является бит. Он может быть в состоянии Включён (1) или Выключен (0). Группа из восьми связанных битов составляет байт, из которых семь бит используются для данных, а ещё один используется для контроля чётности. Согласно правилу чётности, количество битов, которые Включены (1) в каждом байте, всегда должно быть чётным. То есть бит чётности имеет значение 1, если у соответствующего байта количество 1-х битов нечётно. 0 — если иначе (чётно).

Таким образом, бит чётности используется для того, чтобы сделать количество битов в байте чётным. Если соотношение является нечётным, система предполагает, что произошла ошибка соотношения (хотя и редко), которая могла быть вызвана неисправностью оборудования или электрическими помехами.

Выше бит чётности рассмотрен на примере "even parity", то есть «чётная чётность». Также существует "odd parity", то есть «нечётная чётность». В первом случае подгоняется под чётное количество единиц как было показано выше. А во втором случае подгоняется под нечётное количество единиц.

Процессор поддерживает следующие размеры данных -

 + Word: 2-байтовый элемент данных
 + Doubleword: a 4-байтовый (32 бита) элемент данных
 + Quadword: 8-байтовый (64 бита) элемент данных
 + Paragraph: 16-байтовая (128 бита) область
 + Kilobyte: 1024 байт
 + Megabyte: 1,048,576 байт

### Двоичная система счисления

В каждой системе счисления используются позиционные обозначения, то есть каждая позиция, в которой записана цифра, имеет различное позиционное значение. Каждая позиция — это степень базы, которая равна 2 для двоичной системы счисления, и эти степени начинаются с 0 и увеличиваются на 1.

Значение двоичного числа, как и в десятичном, зависит от составляющих его цифр и расположения этих цифр. Но в двоичном числе используются только цифры 1 и 0, и расположение цифр имеет другое значение степени. Первая цифра, как и в десятичном числе, может означать 0 или 1. Вторая цифра (смотрим число справа на лево) может означать 2 (если этот бит установлен на 1) или 0 (если бит установлен на 0). Третья цифра (смотрим число справа на лево) может означать 4 (если этот бит установлен на 1) или 0 (если бит установлен на 0). И так далее. В десятичном числе значение каждого символа нужно умножить на 10 в степени порядкового номера этой цифры за минусом единицы.

То есть число 1337 это 1 * 10^3 + 3 * 10^2 + 3 * 10^1 + 7 * 10^0 = 1337

В двоичной системе всё точно также, только вместо десятки в степени порядкового номера за минусом единицы, нужно использовать двойку — вот и всё!

Допустим число 110101 и мы хотим узнать, сколько это будет в десятичной системе счисления, для этого достаточно выполнить следующее преобразование:

1 * 2^5 * + 1 * 2^4 + 0 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0 = 1 * 32 + 1 * 16 + 0 * 8 + 1 * 4 + 0 * 2 + 1 * 1 = 53

Итак, значение бинарного числа основывается на наличии битов 1 и их позиционном значении. Поэтому значение числа 11111111 в двоичной системе является:

Итак, значение бинарного числа основывается на наличии битов 1 и их позиционном значении. Поэтому значение числа 11111111 в двоичной системе является:

1 + 2 + 4 + 8 +16 + 32 + 64 + 128 = 255

Кстати, это то же самое, что и 2^8 - 1.

### Шестнадцатеричная система счисления

Шестнадцатеричная система счисления использует основание 16. Цифры в этой системе варьируются от 0 до 15. По соглашению, буквы от A до F используются для представления шестнадцатеричных цифр, соответствующих десятичным значениям с 10 по 15.

Шестнадцатеричные числа в вычислениях используются для сокращения длинных двоичных представлений. По сути, шестнадцатеричная система счисления представляет двоичные данные, деля каждый байт пополам и выражая значение каждого полубайта.

Чтобы преобразовать двоичное число в его шестнадцатеричный эквивалент, разбейте его на группы по 4 последовательные группы в каждой, начиная справа, и запишите эти группы в соответствующие цифры шестнадцатеричного числа.

Пример — двоичное число 1000 1100 1101 0001 эквивалентно шестнадцатеричному - 8CD1

Чтобы преобразовать шестнадцатеричное число в двоичное, просто запишите каждую шестнадцатеричную цифру в её 4-значный двоичный эквивалент.

Пример - шестнадцатеричное число FAD8 эквивалентно двоичному - 1111 1010 1101 1000

### Отрицательные двоичные числа

Компьютерные процессы действуют по своей логике и своим алгоритмам. И привычные нам операции вычитания, деления, умножения выполняются необычным для нас, но удобным для микропроцессора способом.

Удобством для арифметических действий в процессоре обусловлено то, как записываются отрицательные двоичные числа. Вы должны помнить из курса информатики, что в одном байте содержится 8 бит. Но старший бит используется для установки знака. Чтобы правильно прочесть число, а также правильно поменять его знак, нужно выполнять следующие правила:

Во-первых, нужно помнить, что если старшие биты (крайние слева), равны нулю, то их иногда не записывают. Например, восьмибитное число 10 (в десятичной системе счисления оно равно 2), также можно записать как 0000 0010. Обе эти записи означают число 2.

Если старший бит равен нулю, то это положительное число. Например, возьмём число 110. В десятичной системе счисления это 6. Данное число является положительным или отрицательным? На самом деле, однозначно на этот вопрос можно ответить только зная разрядность числа. Если это восьмиразрядное число, то его полная запись будет такой: 0000 0110. Как можно увидеть, старший бит равен нулю, следовательно, это положительное число.

Для смены знака недостаточно просто поменять единицу на ноль — для преобразования числа в отрицательное, а также для чтения отрицательного числа существуют особые правила

Отрицательные двоичные числа записываются без знака минус и для получения этого же числа со знаком минус (то есть для получения числа в Дополненном коде) нужно выполнить два действия:

1. нужно переписать его полную форму с противоположным значением битов (то есть для единиц записываются нули, а для нулей записываются единицы)
2. и затем добавить к этому числу 1.

На русском языке такая форма записи называется Дополнительный код, в англоязычной литературе это называется Two's complement.

Примеры восьмибитного двоичного числа в Дополнительном коде (старший бит указывает на знак):

Числа в дополненном коде удобно применять для вычитания — это будет показано далее.

Для преобразования отрицательного числа, записанного в дополнительном коде, в положительное число, записанное в прямом коде, используется похожий алгоритм.

Рассмотрим пример с числом -5. Запись отрицательного восьмибитного числа:

1111 1011

Инвертируем все разряды отрицательного числа -5, получая таким образом:

0000 0100

Добавив к результату 1 получим положительное число 5 в прямом коде:

0000 0101

И проверим, сложив с дополнительным кодом

0000 0101 + 1111 1011 = 1 0000 0000, десятый разряд выбрасывается, то есть получается 0000 0000, то есть 0. Следовательно, преобразование выполнено правильно, так как 5 + (-5) = 0.

### Адресация данных в памяти

Процесс, посредством которого процессор управляет выполнением инструкций, называется циклом fetch-decode-execute (выборки-декодирования-выполнения) или циклом выполнения (execution cycle). Он состоит из трёх непрерывных шагов -

 + Извлечение инструкции из памяти
 + Расшифровка или идентификация инструкции
 + Выполнение инструкции

Процессор может одновременно обращаться к одному или нескольким байтам памяти. Давайте рассмотрим шестнадцатеричное число 0725H (буква H означает, что перед нами шестнадцатеричное число). Для этого числа потребуется два байта памяти. Байт старшего разряда или старший значащий байт — 07, а младший байт — 25.

Процессор хранит данные в последовательности обратного байта, то есть байт младшего разряда хранится в низком адресе памяти и байт старшего разряда в старшем адресе памяти. Таким образом, если процессор переносит значение 0725H из регистра в память, он сначала перенесёт 25 на нижний адрес памяти и 07 на следующий адрес памяти.

Когда процессор получает числовые данные из памяти для регистрации, он снова переворачивает байты. Есть два вида адресов памяти:

 + Абсолютный адрес — прямая ссылка на конкретное место.
 + Адрес сегмента (или смещение) — начальный адрес сегмента памяти со значением смещения.

## Основы синтаксиса Ассемблера

Программу на языке Ассемблер можно разделить на три раздела:

 + Раздел data
 + Раздел bss
 + Раздел text

### Раздел data

Раздел data используется для объявления инициализированных данных или констант. Эти данные не изменяются во время выполнения. В этом разделе вы можете объявить различные постоянные значения, имена файлов или размер буфера и т. д.

Синтаксис объявления раздела data:

```asm
section.data
```

### Раздел BSS

Секция bss используется для объявления переменных. Синтаксис объявления раздела bss:

```asm
section.bss
```

### Раздел text

Раздел text используется для хранения самого кода. Этот раздел должен начинаться с объявления global _start, которое сообщает ядру, где начинается выполнение программы.

Синтаксис объявления раздела text:

```asm
section.text
   global _start
_start:
```

### Комментарии

Комментарий на ассемблере начинается с точки с запятой (;). Он может содержать любой печатный символ, включая пробел. Он может появиться в строке сам по себе, например:

```asm
; Эта программа отображает сообщение на экране
```

или в той же строке вместе с инструкцией, например:

```asm
add eax, ebx     ; добавляет ebx к eax
```

### Операторы Ассемблера

Программы на ассемблере состоят из трёх типов операторов:

 + Исполняемые инструкции или инструкции,
 + Директивы ассемблера или псевдооперации (pseudo-ops), и
 + Макросы.

Исполняемые инструкции или просто инструкции говорят процессору, что делать. Каждая инструкция состоит из кода операции (opcode). Каждая исполняемая инструкция генерирует одну инструкцию на машинном языке.

Директивы ассемблера или псевдооперации говорят ассемблеру о различных аспектах процесса сборки. Они не являются исполняемыми и не генерируют инструкции машинного языка.

Макросы — это в основном механизм подстановки текста.

Синтаксис операторов ассемблера

Операторы языка ассемблера вводятся по одной инструкции в каждой строке. Каждое утверждение имеет следующий формат:

```txt
[label]   мнемоника   [операнды]   [;комментарий]
```

Поля в квадратных скобках являются необязательными. Основная инструкция состоит из двух частей: первая — это имя инструкции (или мнемоника), которая должна быть выполнена, а вторая — операнды или параметры команды.

Ниже приведены некоторые примеры типичных операторов языка ассемблера.

```asm
INC COUNT        ; Увеличить переменную памяти COUNT
 
MOV TOTAL, 48    ; Перемести значение 48 в
                 ; переменную памяти TOTAL
                       
ADD AH, BH       ; Добавить содержимое регистра
                 ; BH в регистр AH
                       
AND MASK1, 128   ; Выполнить операцию AND на переменной
                 ; MASK1 и 128
                       
ADD MARKS, 10    ; Добавить 10 к переменной MARKS
MOV AL, 10       ; Перенести значение 10 в регистр AL
```

## Программа Hello World на Ассамблере

Следующий код на ассемблере выводит на экран строку «Hello World»:

```asm
section .text
   global _start     ;должно быть объявлено для линкера (linker) (ld)
     
_start:             ;показывает линкеру точку входа
   mov  edx,len     ;длина сообщения
   mov  ecx,msg     ;сообщение для записи
   mov  ebx,1       ;файловый дескриптор (stdout - стандартный вывод)
   mov  eax,4       ;номер системного вызова (sys_write)
   int  0x80        ;вызов ядра
     
   mov  eax,1       ;номер системного вызова (sys_exit)
   int  0x80        ;вызов ядра
 
section .data
msg db 'Hello, world!', 0xa  ;строка для печати
len equ $ - msg     ;длина строки
```

Когда приведённый выше код скомпилирован и выполнен, он даст следующий результат:

```txt
Hello, world!
```

Источники для изучения ассемблера:

 + [Введение в ассемблер](https://hackware.ru/?p=8654)
 + [ASCII таблица](https://www.asciitable.com/)
 + [Погружение в ассемблер](https://xakep.ru/2017/09/11/asm-course-1/)
 + [От изучающего ассемблер до взломщика программ](https://wasm.in/attachments/skljarov-i-izuchaem-assembler-za-7-dnej-pdf.2906/)
 + [Руководство по ассемблеру MASM intel x86_64](https://metanit.com/assembler/tutorial/)
