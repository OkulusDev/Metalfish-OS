/* Объявляем содержимое нашего заголовка. */
.set ALIGN,    1<<0             /* выравнивать загруженные модули по границам страницы */
.set MEMINFO,  1<<1             /* предоставлять карту памяти (memory map) */
.set FLAGS,    ALIGN | MEMINFO  /* это поле "флаги" заголовка */
.set MAGIC,    0x1BADB002       /* "волшебное" число, позволяющее загрузчику найти заголовок */
.set CHECKSUM, -(MAGIC + FLAGS) /* контрольная сумма */

/*
Объявление заголовка мультизагрузки помечает программу как ядро. Все эти
значения можно найти в стандарте. Загрузчик будет искать этот заголовок
в первых 8 кБ файла ядра, с отступом до 32х-битной границы. Сигнатура может
находиться в отдельной секции, поэтому заголовок может быть принудительно
помещен в начало файла.
*/
.section .multiboot
.align 4
.long MAGIC
.long FLAGS
.long CHECKSUM

/*
Стандарт мультизагрузочности не предусматривает установку значения регистра
указателя на стек (esp), т. е. стек должен предоставляться ядром. По стандарту
происходит выделение (аллокация) памяти для малого стека путём создания символа
в его конце, после происходит выделение 16384 байт для этого и создаётся символ
в начале. На архитектуре x86 стек направлен вниз. Стек находится в отдельной секции,
поэтому его можно пометить как nobits, что означает меньший развер файла ядра,
поскольку он не содержит неинициализированного стека. Стек на x86 должен быть
выровнен до 16 байт в соответствии со стандартом System V ABI и фактическими
расширениями. Компилятор предполагает, что стек выровнен корректно, отсутствие
выравнивания может привести к неопределенному поведению.
*/
.section .bss
.align 16
stack_bottom:
.skip 16384 # 16 KiB
stack_top:

/*
Скрипт компоновщика указывает _start как точку входа ядра, и загрузчик перейдёт
к этой метке сразу после полной загрузки ядра. Не важно, возвращает ли эта функция
значение, на данном этапе загрузчика уже нет.
*/
.section .text
.global _start
.type _start, @function
_start:
    /*
    Загрузчик запускается в защищённом (protected) режиме на x86.
    Прерывания (interrupts) не доступны, как и подкачка страниц памяти (memory paging).
    В этот момоент ЦП находится в состоянии, указанном стандартом мультизагрузочности,
    и под полным контролем ядра. Ядро может только использовать аппаратные функции, либо
    собственный код. Здесь нет ни printf, ни ограничений безопасности, ни каких-либо
    гарантий, ни механизма отладки - только то, что предоставляет само ядно.
    */

    /*
    Чтобы "установить" стек сохраняем указатель на его начало в регистр `esp`.
    Это необходимо сделать на ассемблере, потому что языки как C не могут
    функционировать без стека.
    */
    mov $stack_top, %esp

    /*
    Это хорошее место для инициализации минимального состояния процессора до перехода
    в высокоуровневое ядро. Лучше всего свести к минимуму раннюю среду, в которой важные
    функции отключены. Помните, что процессор еще не полностью инициализирован: инструкции
    с плавающей запятой и расширения набора инструкций, еще не доступны. Здесь должен быть
    загружен GDT и включена подкачка страниц памяти. Функций C++, как глобальные конструкторы
    и исключения, потребуют  поддержки среды выполнения для нормальной работы.
    */

    /*
    Переход в высокоуровневое ядро. ABI требует, чтобы стек был выровнен по 16 байт во время
    вызова инструкции (которая отдаёт 4х-байтный указатель). Изначально стек был выровнен,
    и с тех пор мы поместили в стек несколько байтов, кратное 16 байтам (пока что 0 байт),
    поэтому выравнивание было сохранено, и вызов четко определен.
    */
    call kernel_main

    /*
    Если системе больше нечего делать, то мы оставляем компьютер в бесконечном цикле.
    Для этого мы:
    1) Отключаем прерывания через cli (clear interrupt enable in eflags).
       Они уже отключены загрузчиком, поэтому это необезательно.
       Возможно, что позже вы захотите включить прерывания и вернуться из kernel_main
       (что немного бессмысленно).
    2) Ожидаем следующим прерываним инструкцию hlt (англ. halt - остановки/отключения).
       Т. к. они выключены, это заблокирует компьютер.
    3) Переходим на инструкцию hlt, если это вызвано не маскируемым прерыванием или
       режимом управления системой.
    */
    cli
1:
    hlt
    jmp 1b

/*
Устанавливаем размер символа _start, используя текущую позицию ("."), путём
вычитания позиции метки этого символа. Это может быть полезно при отладке
или реализации стека вызовов (call stack).
*/
.size _start, . - _start
