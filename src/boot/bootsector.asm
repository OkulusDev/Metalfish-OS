; -----------------------------------------------------------------------------
;  Metalfish OS Bootloader source code
;  File: boot/bootsector.asm
;  Title: Загрузочный сектор и вывод строк (bootsector)
;  Last Change Date: 29 October 2023, 16:12 (UTC)
;  Author: Okulus Dev
;  License: GNU GPL v3
; -----------------------------------------------------------------------------
; Description:
;  Говорим BIOS, что данное устройство - загрузочное, что здесь установлен
;   загрузочный сектор
;  Для вывода строки мы будем использовать "функцию" из другого файла
;  Когда процессор запущен в его начальном режиме (16-bit real mode), 
;	максимальный размер регистров = 16 бит, поэтому самый большой размер, 
;	который мы можем использовать это 0xffff, который равен примерно 64 KB.
;	Чтобы преодолеть этот лимит, существуют специальные регистры, которые 
;	называются регистры сегментов - CS, DS, SS, ES, означающие Code, Data, Stack
;	и Extra соответственно.
;	Память разделена на сегменты, которые индексированы регистрами сегментов
;	(т.е. к примеру в регистре DS лежит адрес начала Data-сегмента). Поэтому, 
;	когда мы указываем какой-либо 16-битный адрес, процессор автоматически
;	высчитывает абсолютный адрес, сдвигая указанный нами адрес от начала нужного
;	сегмента.
;	Высчитывая абсолютный адрес, процессор умножает на 16 значение в регистре 
;	сегмента и добавляет указанный нами адрес. Например, если мы установим 
;	значение сегмента DS как 0x4d и попробуем сделать что-то вроде 
;	"mov ax, [0x20]", то значение, добавляемое в AX, будет загружено 
;	из адреса 0x4f0 (16 * 0x4d + 0x20).
;	Как можно догадаться, с помощью сегментации мы можем добиться того же, что и
;	с помощью директивы [org <адрес>], как мы делали в ex02/org_demo.asm.
;  Операционная система не уберется в 512 байтов, поэтому нам нужно
;				уметь прочитать что-то с диска.
; -----------------------------------------------------------------------------

[org 0x7c00]

mov bp, 0x8000						; Распологаем наш стек подальше в безопасное
mov sp, bp							; место

mov bx, 0x9000						; Данные из секторов будут загружаться в
									; адрес 0x0000(ES):0x9000(BX), т.е.
									; (ES * 16 + BS), равный 0x90000

mov dh, 2							; Загрузим 2 сектора

call disk_load						; Загружаем диск

mov dx, [0x9000]					; Выводим на экран первое загрузившееся
call puts_hex						; "слово" (т.е. машинное слово = 2 байта)
									; предполагая, что оно будет равно 0xdada
									; (распологается по адресу 0x9000)

mov dx, [0x9000 + 512]				; Выводим на экран первое "слово" из 2-го
									; загруженного нами сектора. Должно быть
									; равно 0xface
call puts_hex

jmp $

%include "src/boot/puts_chars.asm"	    ; Функция вывода символов
%include "src/boot/puts_hex.asm"		; Функция печати 16-ричного числа
%include "src/boot/diskload.asm"		; Функция чтения диска

HEX_OUT:
	db "0x0000", 0

times 510-($-$$) db 0
dw 0xaa55

; БИОС загрузит только первые 512 байтов с диска, поэтому если мы специально
; добавим пару секторов (тоже по 512 байт), мы сможем убедиться в том что у 
; нас получилось загрузить эти самые сектора. 
; TODO: explain better.

times 256 dw 0xdada					; второй сектор
times 256 dw 0xface					; третий сектор
