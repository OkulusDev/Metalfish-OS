; ------------------------------------------------------------------------------
;  Metalfish OS Bootloader source code
;  File: boot/puts_hex.asm
;  Title: Вывод hex-символов (bootsector)
;  Last Change Date: 29 October 2023, 16:12 (UTC)
;  Author: Okulus Dev
;  License: GNU GPL v3
; ------------------------------------------------------------------------------
; Description: null
; ------------------------------------------------------------------------------

puts_hex:
	pusha						; Сохраняем значения регистров в стеке
	mov cx, 0					; Регистр CX будет служить счетчиком

loop1:
	cmp cx, 4					; if (CX < 4)
	jl print					; Переходим к print
	jmp end						; else переходим к end

print:
	mov ax, dx					; В AX теперь 0x1fb6
	and ax, 0x000f				; В AX теперь 6 (последняя цифра от 0x1fb6).
	cmp ax, 9					; if (AX > 9) (проверяем обозначается ли число
								; буквой т.к. мы помним что цифра больше 9 в 
								; 16-ричной системе исчисления обозначается
								; буквой латинского алфавита)
	jg num_to_abc				; Переходим к num_to_abc
	jmp next

num_to_abc:						; Перевод числа в букву (так, как она бы
								; выглядела в 16-ричной СИ), например число 15
								; в десятичной будет равно f в 16-ричной
	add ax, 39					; Добавляем к этому числу 39, чтобы затем еще
								; добавить 48 ('0'), получая код 
								; соответсвующего символа в ASCII (например,
								; f (как число, то есть 15) + 39 + 48 (код '0')
								; = 102 (то есть 'f' в ASCII, как нам и нужно)
	jmp next

next:
	add ax, '0'					; Добавляем 48 в AX
	mov bx, HEX_OUT + 5			; Теперь bx указывает на последний символ строки
								; HEX_OUT
	sub bx, cx					; BX = BX - counter (для итерации)
	mov [bx], al				; Так как мы разыменовываем BX (вот так: [BX]),
								; то [BX] это не регистр, а ссылка на память,
								; и так как AX = 16 бит (2 байта), чтобы нам не
								; перезаписать лишнюю память, в [BX] мы помещаем
								; не AX, а AL, размер которого равен 1-му байту.
	ror dx, 4					; было: 0x1fb6, стало: 0x61fb (переносим
								; последнюю цифру в начало)
	inc cx						; counter++
	jmp loop1					; переходим обратно к loop1

end:
	mov bx, HEX_OUT				; Делаем так, чтобы bx снова указывал на первый
								; символ строки HEX_OUT
	call puts_chars				; выводи на экран строку из регистра BX
	popa						; Возвращаем регистрам их изначальное значение
	ret							; Заканчиваем выполнение функции

HEX_OUT:	db "0x0000", 0
